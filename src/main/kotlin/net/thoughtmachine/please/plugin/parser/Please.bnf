{
    parserClass="net.thoughtmachine.please.plugin.parser.PleaseParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Please"
    psiImplClassSuffix="Impl"
    psiPackage="net.thoughtmachine.please.plugin.parser.psi"
    psiImplPackage="net.thoughtmachine.please.plugin.parser.psi.impl"

    elementTypeHolderClass="net.thoughtmachine.please.plugin.parser.psi.PleaseTypes"
    elementTypeClass="net.thoughtmachine.please.plugin.parser.psi.PleaseElementType"
    tokenTypeClass="net.thoughtmachine.please.plugin.parser.psi.PleaseTokenType"

    // Mostly these tokens are just here to provide a basic lexer to enable live preview in intellij.
    //
    // These are actually semi-important to get this thing to generate token types for stuff that doesn't actually
    // appear in the grammar e.g. comments. The tokens are omitted from the token stream by intellij which is nice but
    // we still want to emmit them from the lexer so we can syntax highlight them correctly.
    //
    // TODO(jpoole): remove these once we're done writing the grammar and define the token types somewhere else
    tokens = [
        EQ = "="
        PLUS = "+"
        MINUS = "-"
        LPAREN = "("
        RPAREN = ")"
        LBRACK = "["
        RBRACK = "]"
        LBRACE = "{"
        RBRACE = "}"
        PIPE = "|"
        COMMA = ","
        DEF = "def"
        COLON=":"
        PASS = "pass"
        CONTINUE = "continue"

        TRUE_LIT = "True"
        FALSE_LIT = "False"
        INT_LIT = "regexp:[0-9]+"
        STR_LIT = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
        COMMENT = "regexp:(#)[^\r\n]*"
        DOC_COMMENT = "regexp:(\"\"\")[^\r\n]*"
        IDENT = 'regexp:([a-zA-Z]+|_)([a-zA-Z]|[0-9]|_)*'

        space = "regexp:\w+"
    ]
}

pleaseFile ::= (statement)*
statement ::= (functionDef | expression | assignment | ifStatement | PASS | CONTINUE)

assignment ::= IDENT (COMMA IDENT)* EQ expression

ifStatement ::= IF expression OPEN_BLOCK statement+ ( ELIF expression OPEN_BLOCK statement+ )* [ELSE expression OPEN_BLOCK statement+ ]

functionDef ::= DEF IDENT LPAREN [ functionDefParam (COMMA functionDefParam)* ] COMMA? CLOSE_BLOCK* RPAREN OPEN_BLOCK statement+ CLOSE_BLOCK
functionDefParam ::= IDENT [COLON type [PIPE type+] ] [ EQ expression]
type ::= IDENT

expression ::= [ MINUS | NOT ] value [operator expression] [ IF expression ELSE expression ]
value ::= functionCall | INT_LIT | STR_LIT | listLit | dictLit | boolLit


functionCall ::= IDENT LPAREN [ functionCallParam (COMMA functionCallParam)* ] COMMA? CLOSE_BLOCK* RPAREN
functionCallParam ::= (expression | IDENT "=" expression)


boolLit ::= TRUE_LIT | FALSE_LIT
listLit ::= LBRACK [expression [ (COMMA expression)* ] ] COMMA? CLOSE_BLOCK* RBRACK
dictLit ::= LBRACE [STR_LIT COLON expression [COMMA STR_LIT COLON expression]] COMMA? CLOSE_BLOCK* RBRACE

operator ::= (PLUS | MINUS | TIMES | DIVIDE | PERCENT | LEFT_CHEV | RIGHT_CHEV | AND | OR |
            IS | IS NOT | IN | NOT IN | EQUALS | NOT_EQUALS | GTE | LTE | PIPE)